---
title:        HNSW
date:         2023-11-04
category:     Data Science
math:         true
comments:     true
---

## Hierarchical Navigable Small World

Approximate Nearest Neighbor (ANN) 알고리즘에는 크게 세 가지 카테고리가 존재
- Tree
- Hash
- Graph

HNSW는 이중 graph를 이용한 접근 방식에 속하며, 특히 proximity graph를 기반으로 함
- proximity graph에서 hierarchical navigable small world으로 발전

다른 Vector Search 알고리즘과 달리 HNSW가 가진 특별한 장점은 **증분 색인(incremental indexing)**이 가능하다는 것

### HNSW의 두 가지 주요 기술

**Probability Skip List**

- skip list는 sorted array를 빠르게 탐색하는 linked list 구조이며, 새로운 element를 추가하기도 쉬움
- link는 vertex 간의 연결을 의미하며, skip은 이러한 연결을 건너뜀을 의미
- layer가 내려갈수록 link를 skip하는 횟수가 줄어듬
- ex) 11을 찾기 위해 다음과 같은 규칙으로 layer를 내려간다.
    - current node key가 target(=11)보다 작으면 skip (오른쪽으로 이동)
    - current node key가 target(=11)보다 크면 next layer (아래로 이동)

![image_01](/assets/img/posts/2023-11-04/image_01.png)
    
**Naviable Small World**

- NSW는 proximity graph와 함께 long-range와 short-range link가 주어졌을 때, 탐색 시간을 poly / logarithmic 하게 줄일 수 있다는 아이디어
- ex)
    - 미리 정해둔 entry point에서 출발
    - neighbor를 탐색하여 query vector와 가장 가까운 vertex로 이동
    - 그러면 local minimum으로 수렴
    
![image_02](/assets/img/posts/2023-11-04/image_02.png)
    
- routing은 다음 두 가지 phase로 나뉨
    - zoom out
        - lower degree vertex로 진입
    - zoom in
        - higher degree vertex로 진입
    - zoom out 구간에서는 neighbor 개수가 적어 탐색이 너무 일찍 끝나기 때문에 local minimum의 그리 좋지 못함
        - 탐색이 너무 일찍 멈출 확률을 줄이기 위해 vertex의 degree의 평균을 올리는 방법이 있음
            - 그러면 network의 복잡도 및 탐색 시간이 증가
        - 따라서 recall과 search speed 간의 trade off가 있음
    - HNSW는 zoom in을 먼저 수행하여 성능을 향상
- 가장 상위의 layer는 가장 긴 link를 가지며, higher degree vertex들임
    - 아래로 내려갈수록 degree는 줄어들며, 따라서 zoom-in phase
    - 위 layer에 존재하는 vertex는 아래 layer에도 존재하도록
- 새로운 vertex는 확률적으로 layer에 추가됨
    - 가장 아래부터 uniformly하게 포함
    - 위로갈수록 cumulative하게 확률 계산
        
    ![image_03](/assets/img/posts/2023-11-04/image_03.png)
        
    - layer간의 overlap을 최소화할 수록 성능에 좋다.
        - level multiplier m_L을 낮추면 overlap이 최소화 where L := ( # of layer )
        - 하지만 traversal time이 증가하므로 역시나 trade-off
        - level multiplier의 가장 좋은 값은 1 / ln(M), M = # of neighbors (아래에서 자세히 설명)
            - “A rule of thumb”

### Search 과정

1. 가장 상위 layer의 entry point로 진입
2. local minimum에 빠질때까지 greedy하게 nearest neighbor 탐색
3. local minimum에 빠지면, 하위 layer로 진입
4. 가장 아래 layer에서 local minimum에 빠질때까지 2 ~ 3 과정 반복

![image_04](/assets/img/posts/2023-11-04/image_04.png)

### Hyperparameter

- ef
    - 한번에 탐색하는 nearest neighbor 개수
- efConstruction
    - target layer에서의 nearest neighbor 개수
    - ef, M ≤ efConstruction
    - 새로 들어온 inserted element q에 대해 최근접이웃 및 다음 layer의 entry points 역할
- M
    - vertex가 추가되었을 때, layer에서 가장 가까운 M개의 vertex를 골라 link를 붙임
    - vertex가 많은 layer에서 더 많은 link가 생기도록 M_max 설정 가능
    - 가장 아래 layer에서의 link 개수를 따로 설정 가능 M_max0

## Open source

### Framework
- [milvus](https://github.com/milvus-io/milvus)
- [redisearch](https://github.com/RediSearch/RediSearch)
- [elasticsearch](https://github.com/elastic/elasticsearch)
- [qdrant](https://github.com/qdrant/qdrant)
- [weaviate](https://github.com/weaviate/weaviate)

### Library
- [faiss](https://github.com/facebookresearch/faiss)
- [hnswlib](https://github.com/nmslib/hnswlib)

## Reference
- [Efficient and robust approximate nearest neighbor search using Hierarchical Navigable Small World graphs](https://arxiv.org/abs/1603.09320)
- [Faiss: The Missing Manual](https://www.pinecone.io/learn/series/faiss/hnsw/)