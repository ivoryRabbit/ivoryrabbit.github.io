---
title:        Airbyte (1) - Data Ingestion, 그런데 이제 Airbyte를 곁들인
date:         2024-10-06
categories:   [Data, Engineering]
comments:     true
---

최근 많은 회사에서 Data Ingestion 도구 중 하나인 `Airbyte`를 도입하고 있다. 이번 글에서는 Data Ingestion과 Airbyte가 무엇인지 알아보고자 한다.

본론으로 들어가기 앞서, 이 글을 읽고 있을 데이터 분야 종사자분들께 Airbyte의 공식 블로그 방문을 강력하게 추천하고 싶다. 이곳에는 데이터 엔지니어링에 관한 글들이 매우 매우 잘 정리되어 있다!

- [All Data Engineering Resources](https://airbyte.com/data-engineering-resources){: target="_blank"}

## Data Ingestion

Data Ingestion이란, 다양한 소스로부터 데이터를 수집하여 이를 분석에 용이한 환경으로 적재하는 과정을 의미한다. 이때 데이터 소스는 MySQL과 같은 데이터베이스 뿐만 아니라 API, 파일 시스템 등이 될 수 있으며, 분석 환경은 데이터 웨어하우스 또는 데이터 레이크가 될 수 있다.

그렇다면 왜 Data Ingestion이 필요할까?

첫번째는 여러 곳에 나뉘어 있는 데이터를 한 곳으로 통합하기 위함이다. 예를 들어 상품 카테고리 별 클릭 수를 계산하고 싶다면, 데이터베이스 속 상품 카테고리 정보와 파일 시스템 속 유저 클릭 로그를 동일한 환경에 위치시켜야 한다.

따라서 데이터의 활용도를 높이기 위해서는 서로 다른 출처의 데이터들을 미리 정해진 하나의 분석 환경으로 옮기는 통합 과정이 필요하다.

두번째 이유로는 운영 환경과 분석 환경을 분리하기 위함이다. 만약 운영 환경에서 데이터 분석을 진행한다면, 읽기 자원을 공유하는 서비스 유저들에게 불편함을 유발하거나 자칫 권한 관리 미흡으로 인해 보안 문제가 발생할 수 있다.

이때 분석 환경은 운영 환경과는 별도의 환경을 사용하되, 이왕 분리할거라면 데이터 분석에 최적화되고 확장성을 가진 데이터 웨어하우스로 데이터를 복제하는 것이 좋다.

### Data Ingestion Types

Data Ingestion 방식에는 크게 두 가지 유형이 있다. 지금까지의 데이터 엔지니어링 경험을 보태어 각 방식에 따라 파이프라인 개발 시 어떠한 점들을 고려해야 할지 정리해보았다.

| Batch Ingestion | Real-time Ingestion |
| --- | --- |
| 데이터를 묶어서(batch) 처리 | 실시간으로 데이터를 처리 |
| 비용 효율적 | 비용이 비쌈 |
| 정해진 시간에 주기적으로 실행 | 실시간으로 상시 실행 |
| 부하가 집중됨 | 부하가 분산됨 |
| Pull-based model | Push-based model |

#### Batch Ingestion

Batch Ingestion 방식이라면 데이터 소스의 부하에 예민해야 한다. 서비스 이용이 활발한 시간에 파이프라인을 실행하여 읽기 자원을 너무 많이 빼앗아 가도록 해서는 안된다.

또한 확장성(scalability) 있는 application을 개발해야 한다. 테이블의 크기가 클 수록 더 잘게 chunk를 나누어 동시적으로 처리되도록 한다. 한꺼번에 너무 많은 데이터를 추출하면 네트워크 bandwidth에 병목이 발생하게 된다.

#### Real-time Ingestion

Real-time Ingestion 방식이라면 고가용성(High Availability)를 신경써야 한다. Application이 다운되었다가 복구되면 혹시나 데이터 누락이 있을까봐 품질을 점검하게 된다.

Small file problem을 주의해야 한다. 실시간 처리이기 때문에, 파일 시스템에 쌓인 파일의 크기가 작을 수 있다. 이것은 읽기 성능을 떨어뜨리므로 주기적으로 file compaction을 해주어야 한다.

### Data Ingstion Patterns

현재 많은 회사들이 다양한 패턴의 Data Ingestion 파이프라인들을 운영하고 있다. 그 중 가장 흔하게 보이는 패턴들은 다음과 같다.

#### 1. Full Load

우선 데이터베이스의 테이블을 데이터 웨어하우스의 테이블로 덤프(dump)하는 상황을 가정하자.

Full Load는 정해둔 시각에 Batch Ingestion을 실행하여 테이블 속 모든 데이터를 복제하는 패턴이다.

이 방법은 테이블 구조나 데이터 적재 방식을 고려하지 않아도 되어서 매우 편리한 방법이다.

하지만 테이블의 크기가 클 수록 큰 비용과 부하가 발생한다. 따라서 보통은 하루에 한번, 새벽 시간 대에 해당 작업을 진행하게 된다.

Full Load 패턴의 가장 큰 단점은 멱등성(idempotency)이 보장되지 않는다는 것이다. 파이프라인 실행 시점에 따라 소스 테이블의 데이터도 바뀌어 있기 때문에, 장애 복구 상황이나 백필 상황에서 이전과 동일한 결과를 얻기가 쉽지 않다. 이는 데이터 품질 검증을 어렵게 하는 큰 요인이다.

#### 2. Incremental Load

Incremental Load는 마찬가지로 일정한 주기로 Batch Ingestion을 실행하되, 이전 Ingestion 작업 시간으로부터 변경이 일어난 데이터만 복제하여 원본에 병합하는 패턴이다.

이 패턴은 Full Load와 비교하여 매우 적은 데이터를 처리하므로, 데이터 소스에 가해지는 부하가 적다는 장점이 있다. 따라서 실행 주기를 줄여 데이터의 최신성을 높일 수 있다.

다만 이를 구현하기 위해서는 데이터 구조에 제약이 따른다. 변경분을 가져와야 하므로, `modified_at`과 같이 데이터의 업데이트를 감지할 수 있는 컬럼(cursor field)이 반드시 필요하다.

또 데이터 웨어하우스에서 중복을 제거해야 하는 경우엔 Primary Key가 필요하며, 이때 OLAP의 특성으로 인해 full scan이 발생하므로, 아무리 실행 주기를 줄이더라도 실시간 처리 만큼의 최신성 확보는 어렵다.

Incremental Load 패턴은 Full Load 처럼 멱등성을 보장해주지는 못한다. 또한 데이터의 hard deletion에 대처할 수 없다는 단점이 있다. 따라서 soft deletion이 발생하는 테이블에만 적용하거나 Full Load를 적절히 섞어서 스케쥴해주는 방법이 있다.

#### 3. Change Data Capture (CDC)

CDC 패턴은 Real-time Ingestion 방식을 통해 데이터의 모든 변경 사항을 로그로 남긴다. Incremental Load 패턴과의 차이점은, 원본과의 병합에 변경이 일어난 데이터가 아니라 변경 로그를 사용한다는 점이다.

덕분에 이 방법으로는 hard deletion에도 충분히 잘 대처할 수 있는데, Debeizum이나 DynamoDB Streams와 같은 도구들이 `delete_flag`를 잘 지원해주기 때문이다.

또 모든 update event도 로그로 남기기 때문에, 멱등성을 보장할 수 있다. End-of-date 기준으로 로그를 필터링하여 병합하면 다른 데이터들과의 정합성 문제를 해결할 수 있다.

## Airbyte

Airbyte란 Data Ingestion을 위한 도구 중 하나이다. 공식 홈페이지에서는 Airbyte를 다음과 같이 소개하고 있다.

> Airbyte is an open-source data integration engine that helps you consolidate your data in your data warehouses, lakes and databases.

Airbyte의 큰 특징은 위에서 언급한 Data Ingestion의 개념들을 구체화하고, 많은 엔지니어들이 현업에서 고민했었을 패턴들을 추상화했다는 점이다.

### Airbyte Concepts

#### 1. Source

#### 2. Destination

#### 3. Connector

#### 4. Connection

- a source connector + a destination connector
- i.e. pipeline

#### 5. Stream, Record, Field

#### 6. Sync mode
Cursor (for RDB)

#### 7. Resumability

#### 8. Simple Transformations
Typing and Deduping (for RDB)


## Data Mesh

개인적으로 Airbyte는 `Data Mesh`라는 패러다임과 잘 어울리는 오픈소스라고 생각하는데, 그 이유는 다음과 같이 데이터 탈중앙화(=~~데이터 엔지니어 실직~~)를 가능케하고 있기 때문이다.

#### 1. Domain-Oriented Data Ownership

우리가 보고 싶은 데이터가 운영 환경의 MySQL에 있다고 가정해보자. 이를 분석 환경으로 가져와 데이터 분석을 하기 위해서는 데이터베이스 속 데이터를 분석용 데이터베이스로 이관하는 작업(즉, Data Ingestion)이 필요하다.

기존에는 이러한 파이프라인을 개발하는 작업을 중앙 데이터 조직의 엔지니어가 수행함으로써 데이터 공급자(도메인팀 DB 관리자)와 데이터 소비자(데이터 분석가) 사이에 브로커가 불필요하게 끼어 있는 형태였다.

하지만 만약 Airbyte를 사용한다면, 데이터 공급자가 직접 자신의 팀이 필요로 하는 테이블을 Airbyte에 등록 혹은 제외하면 되므로 분석 환경에 데이터를 제공하는 오너십을 가질 수 있다.

#### 2. Self-Serve Data Platform

우리가 보고 싶은 데이터가 모두 위처럼 MySQL에 있다면 좋겠지만 현업에서는 그렇지 않다. DynamoDB나 Cassandra와 같은 NoSQL에 있을 수도 있고, Zendesk나 Google Ads로부터 API를 통해 받아와야할 수도 있다. 심지어 Google Sheet나 SharePoint 처럼 사람에 의해 메뉴얼하게 관리되는 데이터를 가져와야할 때도 있다.

원래라면 이렇게 다양한 데이터 소스들을 대처하기 위해서 데이터 엔지니어가 각 데이터 소스에 맞게 Ingestion 및 Scheduling 전략을 세우고 코드를 작성해야 했다.

하지만 Airbyte를 사용한다면 이미 각 소스 별로 `커넥터`(Connector)를 지원하고 있기 때문에, 별 다른 데이터 엔지니어링 지식 없이도 스스로 파이프라인을 구축하는 것이 가능하다.

![image_01](/assets/img/posts/2024-10-06/image_01.jpg){: width="600" height="400" }

