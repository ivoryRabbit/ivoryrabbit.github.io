---
title:        데이터 시스템 디자인 (1)
date:         2023-12-09
categories:   [Data, Engineering]
comments:     true
---

<!-- <style>
H2 { color: #d2691e }
H3 { color: #cd853f }
H4 { color: #deb887 }
</style> -->

## 들어가기 앞서

데이터 엔지니어가 되고 지금까지 3년이 약간 모자란 정도의 시간이 흘렀습니다. 입사 당시를 돌아보면 지금은 당연하게 생각하는 것들에 의문을 품곤 했었습니다.

_"왜 모든 snapshot을 저장하고 있는 걸까?"_

_"왜 하필 새벽에 스케쥴을 거는 거지?"_

한 때 업무를 수행하면서 가졌던 이러한 의문들을 정리하고, 이를 토대로 데이터 엔지니어에게 도움이 될 만한 내용의 글들을 써보려고 합니다.

첫 주제로는 데이터 엔지니어가 겪는 모든 비극의 시작, Data Ingesion에 대해 다루어 보려 합니다. 그전에 간단한 가정과 용어들을 살펴보겠습니다.

### 가정

#### 1. 서비스 환경과 분석 환경은 분리되어 있습니다.
서비스를 사용하는 고객들이 불편을 겪지 않도록 분석 환경을 서비스 환경으로부터 분리하고, 데이터를 서비스 환경에서 분석 환경으로 흘려보내는 것이 바로 데이터 엔지니어가 존재하는 이유입니다.

#### 2. 분석 환경은 하나로 통일되어 있습니다.
데이터를 충분히 잘 분석하기 위해서는 조인이 필요하며, 이를 위해 하나의 논리적 공간에서 모든 데이터가 조회가능해야 합니다. 이 글에서는 이러한 논리적 공간을 DW(Data Warehouse)라고 부르겠습니다.

## Data Ingestion

Data Ingestion은 데이터를 추출하여 DW로 적재하는데에만 집중하기 위해 기존의 ETL(Extract-Transform-Load) 방식에서 따로 떨어져 나온 개념입니다.

Data Ingestion이 별도로 중요해진 이유는 다음과 같은 문제 때문이라 생각합니다.

#### 1. 서비스 환경에 직접 접근하기 때문에 부하에 예민합니다. 
분석을 위해 서비스 이용자들이 불편을 겪게 해선 안되니까요.

#### 2. 데이터 추출이 필요한 source가 너무나도 다양합니다. 
반면 데이터 엔지니어는 어떤 source를 사용할 것인지 결정할 수 없습니다. 따라서 source에 따라 서로 다른 데이터 수집 도구를 사용해야 할 수도 있습니다.

#### 3. 보안에 신경써야 합니다.
데이터가 분석 환경으로 옮겨지면 임직원들에게 노출되므로 민감한 정보는 이 단계에서 걸러져야 합니다. 또 필요에 따라 암호화 및 복호화 과정을 거쳐야 합니다.

---

데이터를 가공 또는 변환(Transform)하는 동시에 위의 문제들을 해결하기는 생각보다 어렵습니다. 따라서 일단 추출(Extract)한 그대로의 데이터를 DW에 적재(Load)하는 방식을 주로 이용합니다.

이때 적재하고자 하는 데이터가 어떠한 특징을 가지냐에 따라 Data Ingestion의 전략을 다르게 가져갈 수 있습니다.

#### Mutable Data and Immutable Data
데이터가 이미 한번 기록된 후에도 업데이트가 발생한다면 Mutable Data 라고 합니다. 예를 들어 상품 정보 데이터는 상품 이름이나 가격이 얼마든지 변경될 수 있습니다.

반면 데이터가 이미 생성되어 수정이 불가능한 경우에는 Immutable Data 라고 합니다. 상품 클릭 로그는 한번 쌓이면 그 값이 다시 변경되지 않습니다.

이러한 특징을 고려하여 DW의 테이블을 설계할 때 다양한 방식을 적용할 수 있습니다.

### 1. Full Refresh (Snapshot)
가장 보편적이고 간단한 적재 방법입니다. 날짜 파티션을 만들고 주기적으로 스냅샷을 찍어 각 파티션에 저장 합니다.

데이터의 크기가 큰 경우에는 predicate 단위로 쿼리를 쪼개어 병렬로 처리를 수행할 수 있습니다.

#### 장점
- Ingestion 방식이 가장 간단합니다.
- 매일 스냅샷을 찍어두면 분석 단에서 예전 데이터를 신뢰하고 분석할 수 있습니다.
- 데이터에 문제가 생긴 경우 backfill 하기 쉽습니다.

#### 단점
- 모든 데이터를 추출하기 때문에 데이터가 많을 수록 서비스 환경에 큰 부하를 줍니다. 따라서 주로 트래픽이 적은 새벽에 작업이 진행됩니다.
- 데이터가 많을 수록 저장 비용이 크게 증가합니다.

### 2. Accumulative
만약 Immutable Data를 적재하는 경우라면 Snapshot을 찍을 필요가 없습니다.

적재할 데이터가 수정되지 않기 때문에 날짜 파티션을 만들고 그 날짜에 생성된 데이터를 각 파티션에 저장할 수 있습니다.

#### 장점
- 날짜 별로 파티션되어 있어 특정 상황에서 데이터 조회가 빠릅니다.
- Snapshot에 비해 저장 비용이 저렴합니다.

#### 단점
- Immutable Data를 적재할 때만 사용 가능한 방법입니다.
- Source 테이블에 created_at 등 생성이 발생한 시점을 가리키는 컬럼을 추가해주어야 합니다.

### 3. Incremental
Full Refresh은 편리하지만 데이터의 크기가 커질수록 여러 문제가 발생하게 됩니다. 게다가 변경이 자주 일어나지 않는 테이블의 경우 Snapshot을 찍는 것이 매우 비효율적일 수 있습니다.

이런 경우에는 변경이 일어난 데이터만 추출하여 기존 데이터에 merge하는 식으로 테이블을 동기화하거나 새로운 파티션을 생성할 수 있습니다.

#### 장점
- 증분 데이터만 추출하기 때문에 부하가 적고 처리 속도가 빠릅니다.
- 추출 주기를 줄일 수 있어 새로운 데이터가 반영되는 latency를 줄일 수 있습니다.
- Snapshot 방식에 비해 비용이 저렴합니다.

#### 단점
- 테이블의 크기가 크다면 merge가 단순 insert보다 처리 시간이 더 오래 걸릴 수 있습니다.
- Delete가 반영되지 못할 수도 있습니다.
- Source 테이블에 modified_at 등 변경이 발생한 시점을 가리키는 컬럼을 추가해주어야 합니다.

### 4. Capture Data Change
데이터가 변경되는 정보가 분석에 필요한 경우도 있습니다.

이러한 경우에는 테이블을 최신의 상태로 동기화만 시켜주되 변경분은 별도의 테이블에 저장하여 분석에 사용할 수 있습니다.

#### 장점
- 분석단에서 데이터가 변경된 모든 내역을 사용할 수 있습니다.
- 필요하다면 변경분과 조인하여 해당 시간에 대한 스냅샷을 생성할 수 있습니다.
- CDC 데이터를 Incremental 방식에 적용할 수 있습니다.

#### 단점
- 데이터 변경 로그를 Ingestion 하는 별도의 파이프라인을 개발해야 합니다.
